---
title: "W2-Network"
output: html_document
date: "2025-06-16"
---

```{r Load Packages}
packages <- c("tidyverse", "haven", "dplyr","igraph", "reshape2", "qgraph")
lapply(packages, function(pkg) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg)
  }
  library(pkg, character.only = TRUE)
})
```

```{r Wave 2 data Formating}
#Convert wave 2 data cbcl with new category labels and excluding total score to wide format 

cbcl_wide_wave2 <- cbcl_long_wave2 %>%
  filter(category != "Total Score CBCL") %>%  # optional: exclude total
  pivot_wider(names_from = category, values_from = score)
```

```{r Plotting Network using Lasso + Centrality Analysis from (Fritz et al, 2020)}
# Step 1 Create Correlation matrix (excluding 'folio')
symptom_data2 <- cbcl_wide_wave2 %>% select(-folio) #filtering participant ID 
symptom_corr2 <- cor(symptom_data2, use = "pairwise.complete.obs") # cor function computes the correlation between columns x and y,  "pairwise.complete.obscomputes each pairwise correlation using only the rows (observations) that have non-missing values for that pair of variables

# Step 2 Apply graphical lasso using qgraph
# This automatically estimates a regularized partial correlation network
symptom_glasso2 <- qgraph(
  symptom_corr2,
  graph = "glasso",#obtain an optimal sparse estimate of the partial correlation matrix using the glasso package (Friedman, Hastie and Tibshirani, 2011)
  sampleSize = nrow(symptom_data2),
  layout = "spring",  # "spring" gives a force embedded layout, other options are "circle" or "groups", in fritz paper she used "layout"
  details = TRUE,
  minimum = 0.1,      # filter edges below this value not sure if we should filter for a maximum too 
  edge.color = "skyblue",
  edge.width = 1,     # qgraph auto scales edge widths
  nodeNames = colnames(symptom_corr2),
  theme = "Hollywood",
  fade = FALSE,
  label.cex = 1.1,
  legend = TRUE,
  legend.cex= 0.5,
  main = "CBCL Symptom Network (Graphical Lasso, r > 0.4)"
)

#Centrality Measure Analysis 
#Output table gives: betweenness centrality, closeness, strength, expected influence, shortest path length 
W2_Centrality <- centrality_auto(symptom_glasso)
print(W2_Centrality)
```

```{r Calcualting Global Network Strength, Hypothesis 1 }
#Use the getWmat to extract the weight matrix (edge weights) from a qgraph object 
edge_weights_matrix2 <- getWmat(symptom_glasso2) #In resulting adjacency matrix each cell represents the edge weight correlation between variables can be positive (direct relationship ) or negative (inverse relationship) or 0 (no edge)

# Calculating global strength by using calculated edge weight adjacency matrix from above, excludes diagnoal (repeated relationships), extracts only unique edge weights, takes their absolute value and adds them all up thus global network  strength = sum of absolute edge weights
#Once we wave the global connectivity for other waves we can compare to see if other waves have greater or decreased symptomp connectivity 

global_network_strength_W2 <- sum(abs(edge_weights_matrix2[upper.tri(edge_weights_matrix2)]))
print(global_network_strength_W2)


```

```{r Calcualting Q-index Modularity}
#Modularity measures the strength of division of a network into modules (i.e., communities or clusters). A higher Q (typically 0.3â€“0.7) indicates a clearer, well-separated modular structure.

# Convert edge weight adjacency matrix from above to igraph object
g <- graph_from_adjacency_matrix(edge_weights_matrix2, mode = "undirected", weighted = TRUE, diag = FALSE)

#Convert edge weights to absolute values (lasso does allow for negative weight values)
E(g)$weight <- abs(E(g)$weight)

#Cluster_walktrap function tries to find densley connected subgraphs "communities" in a graph via random walks. The idea is that short random walks tend to stay in the same community 
community2 <- cluster_walktrap(g, weights = E(g)$weight)

#Modularity function calculates how modular is a given division of a graph into subgraphs, from (McElroy et al) Q index >0.3 suggesting nodes are arranged in non-random communities 

modularity_Q_W2 <- modularity(community2)
print(modularity_Q_W2)

```

