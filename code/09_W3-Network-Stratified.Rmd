---
title: "W3-Network-Stratified"
author: "Greta Dertwinkel"
date: "2025-06-26"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Set Up
```{r Load Packages}
packages <- c("tidyverse", "haven", "dplyr","igraph", "reshape2", "qgraph")
lapply(packages, function(pkg) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg)
  }
  library(pkg, character.only = TRUE)
})
```

## Data Formatting
```{r Stratifying Data from Wave 3}
#Merging Subsets with CBCL Data from Wave 2
W3_cbcl_alcohol_use <- merge(alcohol_use_data, cbcl_wide_wave2, by = "folio")

# Merge group 1 or 8 with CBCL wide data
W3_cbcl_no_alcohol<- merge(no_alcohol_group, cbcl_wide_wave2, by = "folio")
```

# Visualisation

## Alcohol Use 
```{r Network for Alcohol Use Group W3}
#Plotting Network using Lasso + Centrality Analysis from (Fritz et al, 2020)}

# Step 1 Create Correlation matrix (excluding 'folio')
symptom_data3SA <- W3_cbcl_alcohol_use  %>% select(-folio, -g9) #filtering participant ID 
symptom_data3SA <- symptom_data3SA %>% select(where(is.numeric)) # Remove non-numeric columns
symptom_corr3SA <- cor(symptom_data3SA, use = "pairwise.complete.obs") # cor function computes the correlation between columns x and y,  "pairwise.complete.obscomputes each pairwise correlation using only the rows (observations) that have non-missing values for that pair of variables

# Step 2 Apply graphical lasso using qgraph
# This automatically estimates a regularized partial correlation network
symptom_glasso3SA <- qgraph(
  symptom_corr3SA,
  graph = "glasso",#obtain an optimal sparse estimate of the partial correlation matrix using the glasso package (Friedman, Hastie and Tibshirani, 2011)
  sampleSize = nrow(symptom_data3SA),
  layout = "spring",  # "spring" gives a force embedded layout, other options are "circle" or "groups", in fritz paper she used "layout"
  details = TRUE,
  minimum = 0.1,      # filter edges below this value not sure if we should filter for a maximum too 
  edge.color = "skyblue",
  edge.width = 1,     # qgraph auto scales edge widths
  nodeNames = colnames(symptom_corr3SA),
  theme = "Hollywood",
  fade = FALSE,
  label.cex = 1.1,
  legend = TRUE,
  legend.cex= 0.5,
  main = "CBCL Symptom Network Alcohol Use Group (Graphical Lasso, r > 0.4)"
)
```

## No Alcohol Use
```{r}
#Plotting Network using Lasso + Centrality Analysis from (Fritz et al, 2020)}

# Step 1 Create Correlation matrix (excluding 'folio')
symptom_data3SN <- W3_cbcl_no_alcohol  %>% select(-folio, -g9) #filtering participant ID 
symptom_data3SN <- symptom_data3SN %>% select(where(is.numeric)) # Remove non-numeric columns
symptom_corr3SN <- cor(symptom_data3SN, use = "pairwise.complete.obs") # cor function computes the correlation between columns x and y,  "pairwise.complete.obscomputes each pairwise correlation using only the rows (observations) that have non-missing values for that pair of variables

# Step 2 Apply graphical lasso using qgraph
# This automatically estimates a regularized partial correlation network
symptom_glasso3SN <- qgraph(
  symptom_corr3SN,
  graph = "glasso",#obtain an optimal sparse estimate of the partial correlation matrix using the glasso package (Friedman, Hastie and Tibshirani, 2011)
  sampleSize = nrow(symptom_data3SN),
  layout = "spring",  # "spring" gives a force embedded layout, other options are "circle" or "groups", in fritz paper she used "layout"
  details = TRUE,
  minimum = 0.1,      # filter edges below this value not sure if we should filter for a maximum too 
  edge.color = "skyblue",
  edge.width = 1,     # qgraph auto scales edge widths
  nodeNames = colnames(symptom_corr3SN),
  theme = "Hollywood",
  fade = FALSE,
  label.cex = 1.1,
  legend = TRUE,
  legend.cex= 0.5,
  main = "CBCL Symptom Network Alcohol Use Group (Graphical Lasso, r > 0.4)")

```
## Side-by-side of stratified networks 
```{r side-by-side of stratified networks}

# 2 plots on top, 1 row for legend below (3 total rows)
layout(matrix(c(1, 2, 3, 3), nrow = 2, byrow = TRUE), heights = c(4, 1))

# Increase margins to leave space for titles
par(mar = c(1, 2, 5, 2))  # bottom, left, top, right

# Network 1 Alcohol Use Group 
qgraph(
  symptom_corr3SA,
  graph = "glasso",
  sampleSize = nrow(symptom_data3SA),
  layout = "spring",
  minimum = 0.1,
  edge.color = "skyblue",
  edge.width = 1.5,
  nodeNames = colnames(symptom_corr3SA),
  theme = "Hollywood",
  fade = FALSE,
  label.cex = 1.1,
  legend = FALSE
)
title("Alcohol Use Group", line = 3, cex.main = 1.6, font.main = 2)

# Network 2  No Alcohol Use Group 
qgraph(
  symptom_corr3SN,
  graph = "glasso",
  sampleSize = nrow(symptom_data3SN),
  layout = "spring",
  minimum = 0.1,
  edge.color = "skyblue",
  edge.width = 1.5,
  nodeNames = colnames(symptom_corr3SN),
  theme = "Hollywood",
  fade = FALSE,
  label.cex = 1.1,
  legend = FALSE
)
title("No Alcohol Use Group", line = 3, cex.main = 1.6, font.main = 2)

#  Legend Section
par(mar = c(0, 0, 0, 0))
plot.new()
legend("center", legend = c(
  "E_R: Emotion Regulation", "A__: Anxiety", "S_C: Somatic Complaints", "Sc_P: Social Problems",
  "SI_P: Sleep Problems", "A_I: Attention Issues", "A_C: Aggression"
), ncol = 3, bty = "n", cex = 1) 
```

# Hypothesis 1
## Alcohol Use 
```{r Calcualting Global Network Strength}
#Use the getWmat to extract the weight matrix (edge weights) from a qgraph object 
edge_weights_matrixW3SA <- getWmat(symptom_glasso3SA) #In resulting adjacency matrix each cell represents the edge weight correlation between variables can be positive (direct relationship ) or negative (inverse relationship) or 0 (no edge)

# Calculating global strength by using calculated edge weight adjacency matrix from above, excludes diagnoal (repeated relationships), extracts only unique edge weights, takes their absolute value and adds them all up thus global network  strength = sum of absolute edge weights
#Once we wave the global connectivity for other waves we can compare to see if other waves have greater or decreased symptomp connectivity 

global_network_strength_W3SA <- sum(abs(edge_weights_matrixW3SA[upper.tri(edge_weights_matrixW3SA)]))
print(global_network_strength_W3SA)
```

## No Alcohol Use
```{r Calcualting Global Network Strength NAU}
#Use the getWmat to extract the weight matrix (edge weights) from a qgraph object 
edge_weights_matrixW3SN <- getWmat(symptom_glasso3SN) #In resulting adjacency matrix each cell represents the edge weight correlation between variables can be positive (direct relationship ) or negative (inverse relationship) or 0 (no edge)

# Calculating global strength by using calculated edge weight adjacency matrix from above, excludes diagnoal (repeated relationships), extracts only unique edge weights, takes their absolute value and adds them all up thus global network  strength = sum of absolute edge weights
#Once we wave the global connectivity for other waves we can compare to see if other waves have greater or decreased symptomp connectivity 

global_network_strength_W3SN <- sum(abs(edge_weights_matrixW3SN[upper.tri(edge_weights_matrixW3SN)]))
print(global_network_strength_W3SN)
```

# Hypothesis 2 and 3
## Alcohol Use
```{r centrality measures and EI}
#Centrality Measure Analysis 
#Output table gives: betweenness centrality, closeness, strength, expected influence, shortest path length 
W3SA_Centrality <- centrality_auto(symptom_glasso3SA)
print(W3SA_Centrality)
```

## No Alcohol Use
```{r centrality measures and EI NAU}
#Centrality Measure Analysis 
#Output table gives: betweenness centrality, closeness, strength, expected influence, shortest path length 
W3SN_Centrality <- centrality_auto(symptom_glasso3SN)
print(W3SN_Centrality)
```


# Hypothesis 4
## Alcohol Use
```{r Calcualting Q-index Modularity}
#Modularity measures the strength of division of a network into modules (i.e., communities or clusters). A higher Q (typically 0.3–0.7) indicates a clearer, well-separated modular structure.

# Convert edge weight adjacency matrix from above to igraph object
gW3SA <- graph_from_adjacency_matrix(edge_weights_matrixW3SA, mode = "undirected", weighted = TRUE, diag = FALSE)

#Convert edge weights to absolute values (lasso does allow for negative weight values)
E(gW3SA)$weight <- abs(E(gW3SA)$weight)

#Cluster_walktrap function tries to find densley connected subgraphs "communities" in a graph via random walks. The idea is that short random walks tend to stay in the same community 
communityW3SA <- cluster_walktrap(gW3SA, weights = E(gW3SA)$weight)

#Modularity function calculates how modular is a given division of a graph into subgraphs, from (McElroy et al) Q index >0.3 suggesting nodes are arranged in non-random communities 

modularity_Q_W3SA <- modularity(communityW3SA)
print(modularity_Q_W3SA)
```

## No Alcohol Use
```{r Calcualting Q-index Modularity NAU}
#Modularity measures the strength of division of a network into modules (i.e., communities or clusters). A higher Q (typically 0.3–0.7) indicates a clearer, well-separated modular structure.

# Convert edge weight adjacency matrix from above to igraph object
gW3SN <- graph_from_adjacency_matrix(edge_weights_matrixW3SN, mode = "undirected", weighted = TRUE, diag = FALSE)

#Convert edge weights to absolute values (lasso does allow for negative weight values)
E(gW3SN)$weight <- abs(E(gW3SN)$weight)

#Cluster_walktrap function tries to find densley connected subgraphs "communities" in a graph via random walks. The idea is that short random walks tend to stay in the same community 
communityW3SN <- cluster_walktrap(gW3SN, weights = E(gW3SN)$weight)

#Modularity function calculates how modular is a given division of a graph into subgraphs, from (McElroy et al) Q index >0.3 suggesting nodes are arranged in non-random communities 

modularity_Q_W3SN <- modularity(communityW3SN)
print(modularity_Q_W3SN)
```
